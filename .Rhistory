View(bike.corr)
bike.corr$P
bike.corr$r
0.4040*0.4048
View(bike.lm1)
bike.lm1$coefficients
bike.lm1$coefficients[2]
bike.corr$r
bike.corr$r[Total.Users,Temperature.F]
bike.corr$r["Total.Users","Temperature.F]"
bike.corr$r["Total.Users","Temperature.F"]
bike.corr$r["Wind.Speed","Temperature.F"]
a<- summart(bike.lm1)
a<- summary(bike.lm1)
View(a)
summary(bike.lm1)$r.squared
bike.lm2.a <- lm(Total.Users~Temperature.F + Temperature.Feels.F, data=bike)
summary(bike.lm2.a)
vif(bike.lm2.a)
VIF(bike.lm2.a)
loadPkg("VIF")
VIF(bike.lm2.a)
?VIF
??VIF
loadPkg("DescTools")
VIF(bike.lm2.a)
VIF(bike.lm2.a)["Temperature.Feels.F "]
VIF(bike.lm2.a)["Temperature.Feels.F"]
bike.lm2.b <- lm(Total.Users~Temperature.F + Hour, data=bike, VIF)
bike.lm2.b <- lm(Total.Users~Temperature.F + Hour, data=bike)
VIF(bike.lm2.b)
bike.lm2.b.summ <- summary(bike.lm2.b)
summary(bike.lm2.b)
summary(bike.lm1)
bike.lm1$coefficients
bike.lm1$coefficients["Temperature.F"]
bike.lm1$coefficients["Temperature.F"][1]
bike.corr$r["Temperature.F","Temperature.Feels.F"]
bike.corr$r["Total.Users","Hour]
bike.corr$r["Temperature.F","Hour"]
bike.corr$r["Temperature.F","Hour"]
ike.lm2.b.vif["Hour"]
bike.lm2.b.vif["Hour"]
bike.lm2.b.vif <- VIF(bike.lm2.b)
bike.lm2.b.vif["Hour"]
bike.lm2.b.summ
bike.lm2.b.summ
View(bike.lm2.b.summ)
bikeorig <- read.csv("bikedata.csv")
variables.drops <- c("Date", "Casual.Users", "Registered.Users") # to be removed
bike <- bikeorig[,!(names(bikeorig) %in% variables.drops)] # subset without drops
classes <- table(sapply(bike, class))
full.model = lm(Total.Users~., data=bike)
stepAIC(full.model, direction = "both",
trace = FALSE)
library(MASS)
loadPkg("MASS")
stepAIC(full.model, direction = "both",
trace = FALSE)
summary(stepAIC(full.model, direction = "both",
trace = FALSE))
step.model <- stepAIC(full.model, direction = "both",
trace = FALSE)
step.model[2]
coef(step.model,2)
summary(step.model$finalModel)
View(step.model)
models <- regsubsets(Total.Users~., data = bike, nvmax = 5,
method = "seqrep")
library(leaps)
models <- regsubsets(Total.Users~., data = bike, nvmax = 5,
method = "seqrep")
models
View(models)
cor(bike)
bike.lm3 <- lm(Total.Users~Temperature.F + Hour + Humidity, data=bike)
summary(bike.lm3)
VIF(bike.lm3)
bike.lm3 <- lm(Total.Users~Temperature.F + Hour + Humidity, data=bike)
bike.lm3.vif <- VIF(bike.lm3)
bike.lm3.summ <- summary(bike.lm3)
print(bike.lm3.summ )
confint(bike.lm3)
bike.lm3.CI <- confint(bike.lm3)
bike.lm3.CI
xkablevif(bike.lm3)
xkabledply(bike.lm3.CI)
names(bike.lm3.CI) <- c("Lower", "Upper")
bike.lm3.CI
bike.lm3.CI <- confint(bike.lm3)
xkablesummary(bike.lm3)
xkabledply(bike.lm3)
xkableply(bike.lm2.b)
# use this function to conveniently load libraries and work smoothly with knitting
# can add quietly=T option to the require() function
# the loadPkg function essentially replaced/substituted two functions install.packages() and library() in one step.
loadPkg = function(x) { if (!require(x,character.only=T, quietly =T)) { install.packages(x,dep=T,repos="http://cran.us.r-project.org"); if(!require(x,character.only=T)) stop("Package not found") } }
# unload/detact package when done using it
unloadPkg = function(pkg, character.only = FALSE) {
if(!character.only) { pkg <- as.character(substitute(pkg)) }
search_item <- paste("package", pkg,sep = ":")
while(search_item %in% search()) { detach(search_item, unload = TRUE, character.only = TRUE) }
}
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
# knitr::opts_chunk$set(include = F)
# knitr::opts_chunk$set(echo = TRUE)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
loadPkg("xtable")
loadPkg("kableExtra")
loadPkg("stringi")
xkabledply = function(modelsmmrytable, title="Table", digits = 4, pos="left", bso="striped", wide=FALSE) {
#' Combining base::summary, xtable, and kableExtra, to easily display model summary.
#' wrapper for the base::summary function on model objects
#' Can also use as head for better display
#' ELo 202004 GWU DATS
#' version 1.2
#' @param modelsmmrytable This can be a generic table, a model object such as lm(), or the summary of a model object summary(lm())
#' @param title Title of table.
#' @param digits Number of digits to display
#' @param pos Position of table, c("left","center","right")
#' @param bso bootstrap_options = c("basic", "striped", "bordered", "hover", "condensed", "responsive")
#' @param wide print table in long (FALSE) format or wide (TRUE) format
#' @return HTML table for display
#' @examples
#' library("xtable")
#' library("kableExtra")
#' xkabledply( df, title="Table testing", pos="left", bso="hover" )
#' xkabledply( ISLR::Hitters[1:5,] )
if (wide) { modelsmmrytable <- t(modelsmmrytable) }
modelsmmrytable %>%
xtable() %>%
kable(caption = title, digits = digits) %>%
kable_styling(bootstrap_options = bso, full_width = FALSE, position = pos)
}
xkabledplyhead = function(df, rows=5, title="Head", digits = 4, pos="left", bso="striped") {
xkabledply(df[1:rows, ], title, digits, pos, bso, wide=FALSE)
}
xkabledplytail = function(df, rows=5, title="Tail", digits = 4, pos="left", bso="striped") {
trows = nrow(df)
xkabledply(df[ (trows-rows+1) : trows, ], title, digits, pos, bso, wide=FALSE)
}
xkablesummary = function(df, title="Table: Statistics summary.", digits = 4, pos="left", bso="striped") {
#' Combining base::summary, xtable, and kableExtra, to easily display numeric variable summary of dataframes.
#' ELo 202004 GWU DATS
#' version 1.2
#' @param df The dataframe.
#' @param title Title of table.
#' @param digits Number of digits to display
#' @param pos Position of table, c("left","center","right")
#' @param bso bootstrap_options = c("basic", "striped", "bordered", "hover", "condensed", "responsive")
#' @return The HTML summary table for display, or for knitr to process into other formats
#' @examples
#' xkablesummary( faraway::ozone )
#' xkablesummary( ISLR::Hitters, title="Five number summary", pos="left", bso="hover"  )
s = summary(df) %>%
apply( 2, function(x) stringr::str_remove_all(x,c("Min.\\s*:\\s*","1st Qu.\\s*:\\s*","Median\\s*:\\s*","Mean\\s*:\\s*","3rd Qu.\\s*:\\s*","Max.\\s*:\\s*")) ) %>% # replace all leading words
apply( 2, function(x) stringr::str_trim(x, "right")) # trim trailing spaces left
colnames(s) <- stringr::str_trim(colnames(s))
if ( dim(s)[1] ==6 ) { rownames(s) <- c('Min','Q1','Median','Mean','Q3','Max')
} else if ( dim(s)[1] ==7 ) { rownames(s) <- c('Min','Q1','Median','Mean','Q3','Max','NA') }
xkabledply(s, title=title, digits = digits, pos=pos, bso=bso )
}
xkablevif = function(model, title="VIFs of the model", digits = 3, pos="left", bso="striped", wide=TRUE) {
#' Combining faraway::vif, xtable, and kableExtra, to easily display numeric summary of VIFs for a model.
#' ELo 202004 GWU DATS
#' version 1.2
#' @param model The lm or compatible model object.
#' @param title Title of table.
#' @param digits Number of digits to display
#' @param pos Position of table, c("left","center","right")
#' @param bso bootstrap_options = c("basic", "striped", "bordered", "hover", "condensed", "responsive")
#' @param wide print table in long (FALSE) format or wide (TRUE) format
#' @return The HTML summary table of the VIFs for a model for display, or for knitr to process into other formats
#' @examples
#' xkablevif( lm(Salary~Hits+RBI, data=ISLR::Hitters), wide=T )
vifs = table( names(model$coefficients)[2:length(model$coefficients)] ) # remove intercept to set column names
vifs[] = faraway::vif(model) # set the values
if (wide) { vifs <- t(vifs) }
xkabledply( vifs, title=title, digits = digits, pos=pos, bso=bso )
}
bikeorig <- read.csv("bikedata.csv")
variables.drops <- c("Date", "Casual.Users", "Registered.Users") # to be removed
bike <- bikeorig[,!(names(bikeorig) %in% variables.drops)] # subset without drops
classes <- table(sapply(bike, class))
bike.rush <- subset(bike, Hour==16)
loadPkg("heatmaply")
loadPkg("Hmisc")
variables.corr <- c("Hour", "Temperature.F", "Temperature.Feels.F",
"Humidity", "Wind.Speed", "Total.Users")
bike.corr <- rcorr(as.matrix(bike[variables.corr]))
bike.corr.heatmap <- heatmaply_cor(
bike.corr$r,
main="Correlation Heatmap for Selected Variables",
dendrogram="none",
grid_color="black"
)
toFactor <- c("Season", "Holiday", "Working.Day", "Day.of.the.Week", "Weather.Type")
bike[ , toFactor] <- apply(bike[ , toFactor], 2, function(x) as.factor(x))
bike.corr.pheat <-  heatmaply_cor(
bike.corr$r,
node_type = "scatter",
custom_hovertext=matrix(paste("p-value:", bike.corr$P),nrow=6),
point_size_mat=-log10(bike.corr$P+0.00001),
#point_size_name="p-value",
label_names = c("x", "y", "Correlation"),
dendrogram="none",
main="Correlations for Bike with P-values"
)
#bike.pairs <- pairs(bike[variables.corr])
bike.lm1 <- lm(Total.Users~Temperature.F, data=bike)
summary(bike.lm1)
loadPkg("DescTools")
bike.lm2.a <- lm(Total.Users~Temperature.F + Temperature.Feels.F, data=bike)
bike.lm2.a.vif <- VIF(bike.lm2.a)
bike.lm2.b <- lm(Total.Users~Temperature.F + Hour, data=bike)
bike.lm2.b.vif <- VIF(bike.lm2.b)
bike.lm2.b.summ <- summary(bike.lm2.b)
bike.lm3 <- lm(Total.Users~Temperature.F + Hour + Humidity, data=bike)
bike.lm3.vif <- VIF(bike.lm3)
bike.lm3.summ <- summary(bike.lm3)
bike.lm3.CI <- confint(bike.lm3)
bike.lm3.summ
View(bike.lm3.summ)
View(bike.lm3)
coef(bike.lm3)
bike.lm3.summ$coefficients
bike.lm3.summ$coefficients$(Intercept)
bike.lm3.summ$coefficients["(Intercept)"]
bike.lm3.summ$coefficients[1]
View(bike.lm3.summ)
bike.lm3.summ$coefficients[1,4]
bike.lm3.summ$coefficients["(Intercept)","Pr(>|t|)"]
detach("package:DescTools", unload = TRUE)
detach("package:datasets", unload = TRUE)
detach("package:corrplot", unload = TRUE)
detach("package:Formula", unload = TRUE)
detach("package:ggcorrplot", unload = TRUE)
detach("package:ggplot2", unload = TRUE)
detach("package:graphics", unload = TRUE)
detach("package:grDevices", unload = TRUE)
detach("package:heatmaply", unload = TRUE)
detach("package:Hmisc", unload = TRUE)
detach("package:kableExtra", unload = TRUE)
detach("package:lattice", unload = TRUE)
detach("package:leaps", unload = TRUE)
detach("package:MASS", unload = TRUE)
detach("package:methods", unload = TRUE)
detach("package:plotly", unload = TRUE)
fun <- function(x)  100*(x[2] - x[1]^2)^2 + (1 - x[1])^2
fun(2)
fun(c(2,1))
nchoosek(3,2)
nChoosek(3,2)
nChooseK(3,2)
source('~/.active-rstudio-document')
choose(3,2)
source('~/.active-rstudio-document')
binom.test(5,20,0.1)
gbinom(20,0.2)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
binomial_pdf <- function(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
binomial_pdf(n=10, k=3, p=0.2)
dbinom(3,10,0.2)
View(fun)
binomial_pdf <- function(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
hessian(binomial_pdf, p)
library(rootSolve)
hessian(binomial_pdf, p)
hessian(binomial_pdf)
# try dbinom(k,n,p)
binomial_pdf <- function(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
hessian(binomial_pdf,x)
fun <- function(x)  100*(x[2] - x[1]^2)^2 + (1 - x[1])^2
mm  <- nlm(fun, p = c(0, 0))$estimate
(Hes <- hessian(fun, mm))
# can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
solve(Hes)   # estimate of parameter uncertainty
# }
?nlm
mm  <- nlm(binomial_pdf, p = c(0, 0), hessian=T)$estimate
(Hes <- hessian(fun, mm))
# can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
solve(Hes)   # estimate of parameter uncertainty
# }
hessian(fun, mm)
# try dbinom(k,n,p)
binomial_pdf <- function(c(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
hessian(binomial_pdf,x)
mm  <- nlm(binomial_pdf, p = c(0, 0, 0), hessian=T)$estimate
(Hes <- hessian(fun, mm))
# can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
solve(Hes)   # estimate of parameter uncertainty
# }
library(rootSolve)
# try dbinom(k,n,p)
binomial_pmf <- function(c(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
hessian(binomial_pmf,x)
mm  <- nlm(binomial_pmf, p = c(0, 0, 0), hessian=T)$estimate
(Hes <- hessian(binomial_pmf, mm))
# can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
solve(Hes)   # estimate of parameter uncertainty
# }
binomial_pmf <- function(c(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
binomial_pmf <- function(c(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
# try dbinom(k,n,p)
binomial_pmf <- function(c(n,k,p)) choose(n,k) * (p^k) * (1-p)^(n-k)
binomial_pmf <- function(c(n,k,p)) choose(n,k) * (p^k) * (1-p)^(n-k)
# try dbinom(k,n,p)
binomial_pmf <- function(n,k,p) choose(n,k) * (p^k) * (1-p)^(n-k)
hessian(binomial_pmf,x)
mm  <- nlm(binomial_pmf, p = c(0, 0, 0), hessian=T)$estimate
# try dbinom(k,n,p) x=(n,k,p)
binomial_pmf <- function(x) choose(x[1],x[2]) * (x[3]^x[2]) * (1-x[3])^(x[1]-x[2])
binomial_pmf(c(20,3,0.2))
dbinom(3,20,0.2)
mm  <- nlm(binomial_pmf, p = c(0, 0, 0), hessian=T)$estimate
mm  <- nlm(binomial_pmf, p = c(10, 5, 0.1), hessian=T)$estimate
(Hes <- hessian(binomial_pmf, mm))
# can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
solve(Hes)   # estimate of parameter uncertainty
nlm(binomial_pmf, p = c(10, 5, 0.1), hessian=T)
nlm(binomial_pmf, p = c(10, 5, 0.5), hessian=T)$estimate
for (i in 1:length(X)){
a = if (X[i]>=0 & X[i]<=2) 1 else 0
b = if (X[i]>=1 & X[i]<=2) 1 else 0
Y[i] = 1 + (a-(X[i]-1)*b)
}
plot(X,Y,type = 'p', pch=1, lwd = 0.5, cex = 0.5)
X = seq(-2,2,0.1)
Y = rep(NA,length(X))
for (i in 1:length(X)){
a = if (X[i]>=0 & X[i]<=2) 1 else 0
b = if (X[i]>=1 & X[i]<=2) 1 else 0
Y[i] = 1 + (a-(X[i]-1)*b)
}
plot(X,Y,type = 'p', pch=1, lwd = 0.5, cex = 0.5)
library(ISLR)
attach(Wage)
library(ISLR)
attach(Wage)
fit=lm(wage∼poly(age ,4) ,data=Wage)
fit = lm(wage~poly(age,4), data=Wage)
summary(fit)
?boot
for (i=1:4){
fit <- cv.glm(wage~poly(age, degree=i), data=Wage, K=10)
}
for (i=1:4){
fit <- cv.glm(wage~poly(age, degree=i), data=Wage, K=10)
}
library(boot)
for (i=1:4){
fit <- cv.glm(wage~poly(age, degree=i), data=Wage, K=10)
}
for (i in 1:4){
fit <- cv.glm(wage~poly(age, degree=i), data=Wage, K=10)
}
data.full <- read.csv("melb_data.csv")
y = (0; 0; 0; 0; 1; 1; 1; 1)
y = (0, 0, 0, 0, 1, 1, 1, 1)
y = (0, 0, 0, 0, 1, 1, 1, 1)
y = c(0; 0; 0; 0; 1; 1; 1; 1)
y = c(0, 0, 0, 0, 1, 1, 1, 1)
x1 = c(1, 2, 3, 3, 5, 6, 10, 11).
x1 = c(1, 2, 3, 3, 5, 6, 10, 11)
library(glmnet)
mod.1a <- cv.glmnet(x1, y)
mod.1a <- glm(y~x1)
mod.1a <- glm(y~x1, family="binomial")
summary(mod.1a)
x2 <- c(1, 2, 3, 3, 3, 6, 10, 11)
mod.1b <- glm(y~x2, family="binomial")
summary(mod.1b)
mod.1a <- glm(y~factor(x1), family="binomial")
set.seed(15)
data.full <- read.csv("melb_data.csv")
samps <- sample(nrow(data.full), nrow(data.full)*0.7)
data.train <- data.full[(samps),]
data.test <- data.full[(-samps),]
lapply(data.full, class)
mod <- lm(Price ~ Rooms + Car + Landsize + Distance + Bedroom2 + Bathroom + Car + BuildingArea + Lattitude*Longtitude + Propertycount + factor(Regionname) , data=data.train)
mod2 <- lm(Price ~ Rooms + Car + Landsize + Distance + Bedroom2 + Bathroom + Car + BuildingArea + Lattitude*Longtitude , data=data.train, na.action=NULL)
y.pred <- predict(mod2, data.test)
y.test <- data.test$Price
set.seed(15)
data.full <- read.csv("melb_data.csv")
samps <- sample(nrow(data.full), nrow(data.full)*0.7)
data.train <- data.full[(samps),]
data.test <- data.full[(-samps),]
lapply(data.full, class)
load_data <- function(){
data.full <- read.csv("melb_data.csv")
# create train and test data
samps <- read.csv("sample.txt", sep=" ")
data.train <- data.full[(samps$x),]
data.test <- data.full[(-samps$x),]
return(data.train, data.test)
}
a,b <- load_data()
(a,b) <- load_data()
c(a,b) <- load_data()
setwd("~/Documents/GitHub/DATS6101_proj1_team2_S2021")
load_data <- function(){
data.full <- read.csv("melb_data.csv")
# create train and test data
samps <- read.csv("sample.txt", sep=" ")
data.train <- data.full[(samps$x),]
data.test <- data.full[(-samps$x),]
return(data.train, data.test)
}
c(a,b) <- load_data()
data.full <- read.csv("melb_data.csv")
setwd("~/Documents/GitHub/DATS6101_proj1_team2_S2021")
data.full <- read.csv("melb_data.csv")
samps <- read.csv("sample.txt", sep=" ")
data.full <- read.csv("melb_data.csv")
load_data <- function(){
data.full <- read.csv("melb_data.csv")
# create train and test data
samps <- read.csv("sample.txt", sep=" ")
data.train <- data.full[(samps$x),]
data.test <- data.full[(-samps$x),]
return(data.train, data.test)
}
c(a,b) <- load_data()
load_data <- function(train=T){
data.full <- read.csv("melb_data.csv")
# create train and test data
samps <- read.csv("sample.txt", sep=" ")
data.train <- data.full[(samps$x),]
data.test <- data.full[(-samps$x),]
if (train==T){
return(data.train)
}
else{
return(data.test)
}
}
load_data <- function(train=T){
data.full <- read.csv("melb_data.csv")
# create train and test data
samps <- read.csv("sample.txt", sep=" ")
data.train <- data.full[(samps$x),]
data.test <- data.full[(-samps$x),]
if (train==T){
return(data.train)
}
else{
return(data.test)
}
}
train <-load_data()
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
# knitr::opts_chunk$set(include = F)
knitr::opts_chunk$set(echo = F)
options(scientific=T, digits = 5)
options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
opts_chunk$set(echo = FALSE, cache=F)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
# knitr::opts_chunk$set(include = F)
knitr::opts_chunk$set(echo = F)
options(scientific=T, digits = 5)
options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
read_chunk('../general_support.R')
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
# knitr::opts_chunk$set(include = F)
knitr::opts_chunk$set(echo = F)
options(scientific=T, digits = 5)
options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
source("general_support.R", local = knitr::knit_global())
source("P2_support.R", local = knitr::knit_global())
View(load_data)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
# knitr::opts_chunk$set(include = F)
knitr::opts_chunk$set(echo = F)
options(scientific=T, digits = 5)
options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
# source("general_support.R", local = knitr::knit_global())
# source("P2_support.R", local = knitr::knit_global())
train <- load_data()
train <- load_data()
source("P2_support.R", local = knitr::knit_global())
train <- load_data()
test <- load_data(F)
remove(load_data)
